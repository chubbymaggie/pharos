% Copyright 2017 Carnegie Mellon University.
% ============================================================================================
% Driver rules for forward reasoning
% ============================================================================================

% These rules turn ordinary forward reasoning rules into dynamically asserted facts.  They
% follow a fairly rigid pattern, and might be generated by Prolog meta-programming in the
% future to keep the code cleaner.  These rules have been moved out of rules.pl to make space
% for more important rules that aren't just machinery...

% Each rule takes no parameters because it is supposed to assert a single fact in the same way
% that the guessing rules currently do, and return the callable parameter in "Out".

% The standard form of these rules (with commentary) is:
%
%concludeXXX(Out) :-
%    % We begin with an unbound set of parameters to a reasoning method.  In general, leaving the
%    % parameters unbound, and letting Prolog do it's thing has performed better than trying to
%    % enumerate possible values before calling reasonXXX().  It's a little unclear why, but
%    % that's what Cory's observed.
%    reasonXXX(Parameters),
%
%    % Occasionally there will be additional _fast_ constraints here.  iso_dif in particular
%    may be faster than a table lookup, since it's mostly a built in.
%    iso_dif(Parameter1, Parameter2),
%
%    % Check that the fact hasn't already been asserted.
%    not(factXXX(Parameters)),
%
%    % Check that there's no contradictory reasoning (not always required).
%    not(factNOTXXX(Parameters)),
%
%    % Although we're not doing so right now, it might be beneficial to have certain
%    % constraints that are always required here instead of in each reasoning rule?
%
%    % Report what we're doing for debugging.
%    debug('Concluding factXXX('),
%    debug(Parameters), debugln(') ... '),
%
%    % Then return the assertion in the Out Parameters, so that the caller can call() it to
%    % assert the fact.  Asserting the fact in our caller allows us to backtrack properly, while
%    % making the assertion here directly did not. Also the concludeMergeClasses() rule is a
%    % special case in that it does more than just call try_assert().
%    Out = try_assert(factXXX(Parameters)).

concludeMethod(Out) :-
    reasonMethod(Method),
    not(factMethod(Method)),
    not(factNOTMethod(Method)),
    debug('Concluding factMethod('),
    debug(Method), debugln(') ... '),
    Out = try_assert(factMethod(Method)).

concludeConstructor(Out) :-
    reasonConstructor(Method),
    not(factConstructor(Method)),
    not(factNOTConstructor(Method)),
    debug('Concluding factConstructor('),
    debug(Method), debugln(') ... '),
    Out = try_assert(factConstructor(Method)).

concludeNOTConstructor(Out) :-
    reasonNOTConstructor(Method),
    not(factNOTConstructor(Method)),
    not(factConstructor(Method)),
    debug('Concluding factNOTConstructor('),
    debug(Method), debugln(') ... '),
    Out = try_assert(factNOTConstructor(Method)).

concludeRealDestructor(Out) :-
    reasonRealDestructor(Method),
    not(factRealDestructor(Method)),
    not(factNOTRealDestructor(Method)),
    debug('Concluding factRealDestructor('),
    debug(Method), debugln(') ... '),
    Out = try_assert(factRealDestructor(Method)).

concludeNOTRealDestructor(Out) :-
    reasonNOTRealDestructor(Method),
    not(factRealDestructor(Method)),
    not(factNOTRealDestructor(Method)),
    debug('Concluding factNOTRealDestructor('),
    debug(Method), debugln(') ... '),
    Out = try_assert(factNOTRealDestructor(Method)).

concludeDeletingDestructor(Out) :-
    reasonDeletingDestructor(Method),
    not(factDeletingDestructor(Method)),
    not(factNOTDeletingDestructor(Method)),
    debug('Concluding factDeletingDestructor('),
    debug(Method), debugln(') ... '),
    Out = try_assert(factDeletingDestructor(Method)).

concludeNOTDeletingDestructor(Out) :-
    reasonNOTDeletingDestructor(Method),
    not(factDeletingDestructor(Method)),
    not(factNOTDeletingDestructor(Method)),
    debug('Concluding factNOTDeletingDestructor('),
    debug(Method), debugln(') ... '),
    Out = try_assert(factDeletingDestructor(Method)).

% This fact is only reasoned about, and it's similar to derived constructor.
concludeObjectInObject(Out) :-
    reasonObjectInObject(OuterClass, InnerClass, Offset),
    iso_dif(OuterClass, InnerClass),
    not(factObjectInObject(OuterClass, InnerClass, Offset)),
    % There's no factNOTObjectInObject, since most things aren't in most other things.
    debug('Concluding factObjectInObject('),
    debug(OuterClass), debug(', '),
    debug(InnerClass), debug(', '),
    debug(Offset),debugln(') ....'),
    Out = try_assert(factObjectInObject(OuterClass, InnerClass, Offset)).

concludeDerivedClass(Out) :-
    reasonDerivedClass(DerivedClass, BaseClass, ObjectOffset),
    iso_dif(DerivedClass, BaseClass),
    not(factDerivedClass(DerivedClass, BaseClass, ObjectOffset)),
    not(factNOTDerivedClass(DerivedClass, BaseClass, ObjectOffset)),
    debug('Concluding factDerivedClass('),
    debug(DerivedClass), debug(', '),
    debug(BaseClass), debug(', '),
    debug(ObjectOffset), debugln(') ... '),
    Out = try_assert(factDerivedClass(DerivedClass, BaseClass, ObjectOffset)).

concludeNOTDerivedClass(Out) :-
    reasonNOTDerivedClass(DerivedClass, BaseClass, ObjectOffset),
    iso_dif(DerivedClass, BaseClass),
    not(factDerivedClass(DerivedClass, BaseClass, ObjectOffset)),
    not(factNOTDerivedClass(DerivedClass, BaseClass, ObjectOffset)),
    debug('Concluding factNOTDerivedClass('),
    debug(DerivedClass), debug(', '),
    debug(BaseClass), debug(', '),
    debug(ObjectOffset), debugln(') ... '),
    Out = try_assert(factNOTDerivedClass(DerivedClass, BaseClass, ObjectOffset)).

concludeEmbeddedObject(Out) :-
    reasonEmbeddedObject(OuterClass, InnerClass, ObjectOffset),
    iso_dif(OuterClass, InnerClass),
    not(factEmbeddedObject(OuterClass, InnerClass, ObjectOffset)),
    not(factNOTEmbeddedObject(OuterClass, InnerClass, ObjectOffset)),
    debug('Concluding factEmbeddedObject('),
    debug(OuterClass), debug(', '),
    debug(InnerClass), debug(', '),
    debug(ObjectOffset), debugln(') ... '),
    Out = try_assert(factEmbeddedObject(OuterClass, InnerClass, ObjectOffset)).

concludeNOTEmbeddedObject(Out) :-
    reasonNOTEmbeddedObject(OuterClass, InnerClass, ObjectOffset),
    iso_dif(OuterClass, InnerClass),
    not(factEmbeddedObject(OuterClass, InnerClass, ObjectOffset)),
    not(factNOTEmbeddedObject(OuterClass, InnerClass, ObjectOffset)),
    debug('Concluding factNOTEmbeddedObject('),
    debug(OuterClass), debug(', '),
    debug(InnerClass), debug(', '),
    debug(ObjectOffset), debugln(') ... '),
    Out = try_assert(factNOTEmbeddedObject(OuterClass, InnerClass, ObjectOffset)).

concludeVFTable(Out) :-
    reasonVFTable(VFTable),
    not(factVFTable(VFTable)),
    not(factNOTVFTable(VFTable)),
    debug('Concluding factVFTable('), debug(VFTable), debugln(') ... '),
    Out = try_assert(factVFTable(VFTable)).

% There's no reasoning for NOT a vftable?  The fact might be asserted by a failed guess, but
% that's about as close as we would get to reasoning currently...

concludeVFTableWrite(Out) :-
    reasonVFTableWrite(Insn, Method, Offset, VFTable),
    not(factVFTableWrite(Insn, Method, Offset, VFTable)),
    %not(reasonNOTVFTableWrite(Insn, Method, Offset, VFTable)),
    debug('Concluding factVFTableWrite('),
    debug(Insn), debug(', '),
    debug(Method), debug(', '),
    debug(Offset), debug(', '),
    debug(VFTable), debugln(') ... '),
    Out = try_assert(factVFTableWrite(Insn, Method, Offset, VFTable)).

concludeVFTableOverwrite(Out) :-
    reasonVFTableOverwrite(VFTable1, VFTable2, Offset),
    not(factVFTableOverwrite(VFTable1, VFTable2, Offset)),
    %not(reasonNOTVFTableOverwrite(VFTable1, VFTable2, Offset)),
    debug('Concluding factVFTableOverwrite('),
    debug(VFTable1), debug(', '),
    debug(VFTable2), debug(', '),
    debug(Offset), debugln(') ... '),
    Out = try_assert(factVFTableOverwrite(VFTable1, VFTable2, Offset)).

concludeVFTableEntry(Out) :-
    reasonVFTableEntry(VFTable, VFTableOffset, Address),
    not(factVFTableEntry(VFTable, VFTableOffset, Address)),
    not(factNOTVFTableEntry(VFTable, VFTableOffset, Address)),
    debug('Concluding factVFTableEntry('),
    debug(VFTable), debug(', '),
    debug(VFTableOffset), debug(', '),
    debug(Address), debugln(') ... '),
    Out = try_assert(factVFTableEntry(VFTable, VFTableOffset, Address)).

concludeNOTVFTableEntry(Out) :-
    reasonNOTVFTableEntry(VFTable, VFTableOffset, Address),
    not(factVFTableEntry(VFTable, VFTableOffset, Address)),
    not(factNOTVFTableEntry(VFTable, VFTableOffset, Address)),
    debug('Concluding factNOTVFTableEntry('),
    debug(VFTable), debug(', '),
    debug(VFTableOffset), debug(', '),
    debug(Address), debugln(') ... '),
    Out = try_assert(factNOTVFTableEntry(VFTable, VFTableOffset, Address)).

concludeVFTableSizeGTE(Out) :-
    reasonVFTableSizeGTE(VFTable, Size),
    not((factVFTableSizeGTE(VFTable, KnownSize), KnownSize >= Size)),
    debug('Concluding factVFTableSizeGTE('),
    debug(VFTable), debug(', '),
    debug(Size), debugln(') ... '),
    Out = try_assert(factVFTableSizeGTE(VFTable, Size)).

concludeVFTableSizeLTE(Out) :-
    reasonVFTableSizeLTE(VFTable, Size),
    not((factVFTableSizeLTE(VFTable, KnownSize), KnownSize >= Size)),
    debug('Concluding factVFTableSizeLTE('),
    debug(VFTable), debug(', '),
    debug(Size), debugln(') ... '),
    Out = try_assert(factVFTableSizeLTE(VFTable, Size)).

concludeVirtualFunctionCall(Out) :-
    reasonVirtualFunctionCall(Insn, Method, OOffset, VFTable, TOffset),
    not(factVirtualFunctionCall(Insn, Method, OOffset, VFTable, TOffset)),
    not(factNOTVirtualFunctionCall(Insn, Method, OOffset, VFTable, TOffset)),
    debug('Concluding factVirtualFunctonCall('),
    debug(Insn), debug(', '),
    debug(Method), debug(', '),
    debug(OOffset), debug(', '),
    debug(VFTable), debug(', '),
    debug(TOffset), debugln(') ... '),
    Out = try_assert(factVirtualFunctionCall(Insn, Method, OOffset, VFTable, TOffset)).

concludeClassSizeGTE(Out) :-
    reasonClassSizeGTE(Class, Size),
    not((factClassSizeGTE(Class, KnownSize), KnownSize >= Size)),
    debug('Concluding factClassSizeGTE('),
    debug(Class), debug(', '),
    debug(Size), debugln(') ... '),
    Out = try_assert(factClassSizeGTE(Class, Size)).

concludeClassSizeLTE(Out) :-
    reasonClassSizeLTE(Class, Size),
    not((factClassSizeLTE(Class, KnownSize), KnownSize =< Size)),
    debug('Concluding factClassSizeLTE('),
    debug(Class), debug(', '),
    debug(Size), debugln(') ... '),
    Out = try_assert(factClassSizeLTE(Class, Size)).

concludeClassHasNoBase(Out) :-
    reasonClassHasNoBase(Class),
    not(factClassHasNoBase(Class)),
    not(factClassHasUnknownBase(Class)),
    debug('Concluding factClassHasNoBase('), debug(Class), debugln(') ... '),
    Out = try_assert(factClassHasNoBase(Class)).

concludeClassHasUnknownBase(Out) :-
    reasonClassHasUnknownBase(Class),
    not(factClassHasUnknownBase(Class)),
    not(factClassHasNoBase(Class)),
    debug('Concluding factClassHasUnknownBase('), debug(Class), debugln(') ... '),
    Out = try_assert(factClassHasUnknownBase(Class)).

concludeClassCallsMethod(Out) :-
    reasonClassCallsMethod(Class, Method),
    iso_dif(Class, Method),
    find(Method, ExistingClass),
    iso_dif(Class, ExistingClass),
    not(factClassCallsMethod(Class, Method)),
    %not(factNOTClassCallsMethod(Class, Method)),
    debug('Concluding factClassCallsMethod('), debug(Class), debug(', '),
    debug(Method), debugln(') ... '),
    Out = try_assert(factClassCallsMethod(Class, Method)).

concludeNOTMergeClasses(Out) :-
    reasonNOTMergeClasses(Class1, Class2),
    iso_dif(Class1, Class2),
    not(factMergeClasses(Class1, Class2)),
    not(factNOTMergeClasses(Class1, Class2)),
    % This is the spot that breaks ooex7.
    not(factNOTMergeClasses(Class2, Class1)),
    debug('Concluding factNOTMergeClasses('), debug(Class1), debug(', '),
    debug(Class2), debugln(') ... '),
    Out = try_assert(factNOTMergeClasses(Class1, Class2)).

concludeMergeClasses(Out) :-
    reasonMergeClasses(Method1, Method2),
    not(factMergeClasses(Method1, Method2)),
    not(factNOTMergeClasses(Method1, Method2)),
    debug('Concluding factMergeClasses('),
    debug(Method1), debug(', '),
    debug(Method2), debugln(') ... '),
    Out = ((try_assert(factMergeClasses(Method1, Method2)),
            mergeClasses(Method1, Method2))).

/* Local Variables:   */
/* mode: prolog       */
/* fill-column:    95 */
/* comment-column: 0  */
/* End:               */
